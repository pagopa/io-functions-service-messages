# Azure DevOps pipeline to release a new version and deploy to production.

variables:
  NAMESPACE: 'messages'

parameters:
  - name: 'RELEASE_SEMVER'
    displayName: 'When packing a release, define the version bump to apply'
    type: string
    values:
      - major
      - minor
      - patch
    default: minor
  - name: 'FORCE_REPLACE_DOCKER_IMAGE'
    displayName: 'Force the existing docker image to be replaced'
    type: boolean
    default: False
    values:
      - False
      - True

# Only manual activations are intended
trigger: none
pr: none

# resources:
#   repositories:
#     - repository: pagopaCommons
#       type: github
#       name: pagopa/azure-pipeline-templates
#       ref: refs/tags/v19
#       endpoint: 'io-azure-devops-github-ro'

pool:
  vmImage: 'ubuntu-latest'

stages:

#   # Create a relase
#   # Activated when ONE OF these are met:
#   # - is on branch master 
#   # - is a tag in the form v{version}-RELEASE
#   - stage: Release
#     condition:
#       and(
#         succeeded(),
#         or(
#           eq(variables['Build.SourceBranch'], 'refs/heads/master'),
#           and(
#             startsWith(variables['Build.SourceBranch'], 'refs/tags'),
#             endsWith(variables['Build.SourceBranch'], '-RELEASE')
#           )
#         )
#       )
#     jobs:
#       - job: make_release
#         steps:
#         - ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
#           - template: templates/node-job-setup/template.yaml@pagopaCommons
#             parameters:
#               persistCredentials: true
#           - template: templates/node-github-release/template.yaml@pagopaCommons
#             parameters:
#               semver: '${{ parameters.RELEASE_SEMVER }}'
#               gitEmail: $(GIT_EMAIL)
#               gitUsername: $(GIT_USERNAME)
#               gitHubConnection: $(GITHUB_CONNECTION)

#         - ${{ if ne(variables['Build.SourceBranch'], 'refs/heads/master') }}:
#           - script: |
#               echo "We assume this reference to be a valid release: $(Build.SourceBranch). Therefore, there is no need to bundle a new release."
#             displayName: 'Skip release bundle'

  # Build
  - stage: Build
    #dependsOn:
    #  - Release
    jobs:
      - job: 'Build'
        steps:
          - task: Docker@2
            displayName: 'docker login'
            inputs:
              containerRegistry: 'io-p-messages-acr-docker-registry-prod'
              command: 'login'
          - task: Bash@3
            displayName: 'docker build and push'
            inputs:
              targetType: 'inline'
              script: |
                if [ ${{ parameters.FORCE_REPLACE_DOCKER_IMAGE }} == "True" ]; then
                  echo "Parameter FORCE_REPLACE_DOCKER_IMAGE is set to true, we'll replace existing docker image"
                else
                  # docker will return 0 on success or 1 on failure.
                  docker manifest inspect iopcommonacr.azurecr.io/io-functions-service-messages:latest > /dev/null
                fi

                if [ $? -eq 0 ]; then
                  echo "docker image already exists in the registry, skip build and push"
                else
                  echo "docker image does not exist in the registry or the parameter FORCE_REPLACE_DOCKER_IMAGE is set to true, start build and push"
                  docker build -t iopcommonacr.azurecr.io/io-functions-service-messages:$(Build.BuildId) .
                  docker build -t iopcommonacr.azurecr.io/io-functions-service-messages:latest .
                  docker push iopcommonacr.azurecr.io/io-functions-service-messages:$(Build.BuildId)
                  docker push iopcommonacr.azurecr.io/io-functions-service-messages:latest
                fi

  - stage: 'Serving_helm'
    displayName: 'Serving_Helm'
    dependsOn: Build
    jobs:
      - job: Serving_helm
        displayName: Serving_helm
        steps:
          - task: PublishPipelineArtifact@1
            displayName: 'Publish Artifact manifests'
            condition: succeeded()
            inputs:
              targetPath: '$(Build.Repository.LocalPath)/helm'
              artifact: 'helm'
              publishLocation: 'pipeline'

  - stage: 'Deploy'
    dependsOn: "Serving_helm"
    jobs:
      - deployment: 'Deploy'
        pool:
          name: io-prod-linux
        environment: PROD
        strategy:
          runOnce:
            deploy:
              steps:
                - download: none
                - task: DownloadPipelineArtifact@2
                  inputs:
                    buildType: 'current'
                    artifactName: 'helm'
                    targetPath: '$(Pipeline.Workspace)/helm'
                - task: Bash@3
                  displayName: 'prepare helm'
                  inputs:
                    targetType: 'inline'
                    script: |
                      helm repo add microservice-chart https://pagopa.github.io/aks-microservice-chart-blueprint
                      helm dep build $(Pipeline.Workspace)/helm
                - task: HelmDeploy@0
                  displayName: Helm upgrade
                  inputs:
                    kubernetesServiceEndpoint: io-messages-aks-weu-beta
                    namespace: $(NAMESPACE)
                    command: upgrade
                    chartType: filepath
                    chartPath: $(Pipeline.Workspace)/helm
                    chartName: io-functions-service-messages
                    releaseName: io-functions-service-messages
                    valueFile: "$(Pipeline.Workspace)/helm/values-beta.yaml"
                    install: true
                    waitForExecution: true
                    arguments: "--timeout 5m0s"
